<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/theme/dark.css" id="theme">
  <link
  href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
  rel="stylesheet"
  integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
  crossorigin="anonymous">

  <title>MAP579 - Templates</title>
</head>

<body>
  <div class="reveal">
    <div class="slides">

      <section class="title-section">
        <h1>
          Templates
        </h1>
        <h2>
          MAP 579
        </h2>
      </section>

      <section>
        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Why templates ?
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
int min(int a, int b)
{
  return a &lt; b ? a : b;
}

double min(double a, double b)
{
  return a &lt; b ? a : b;
}
              </code></pre>
              <p class="text-center">Same code for every arithmetic type</p>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Possible solutions (1/3)
              </h1>
            </div>
            <div class="main">

              <p>Use C macros</p>
              <pre><code class="cpp">
#define DEFINE_MIN(TYPE)  \
TYPE min(TYPE a, TYPE b)  \
{                         \
  return a &lt;b ? a : b;    \
}

DEFINE_MIN(int)
DEFINE_MIN(double)
DEFINE_MIN(float)
....
#undef min
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Possible solutions (2/3)
              </h1>
            </div>
            <div class="main">

              <p> Use a common base class for all types</p>
              <pre><code class="cpp">
const object&amp; min(const object&amp; a, const object&amp; b)
{
  return a.less_than(b) ? a : b;
}
              </code></pre>
              <ul>
                <li>limited type checking</li>
                <li>No more value semantics (because of inheritance)</li>
              </ul>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Possible solutions (3/3)
              </h1>
            </div>
            <div class="main">

              <p>C++ templates: similar to C macros, but have it generated by the compiler</p>
              <ul>
                <li>No need to write additional code for new types</li>
                <li>No need to inherit for a common base class</li>
                <li>Full type checking</li>
              </ul>
            </div>
          </div>
        </section>
      </section>

      <section>
        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Function templates
              </h1>
            </div>
            <div class="main">

              <p>
                Function templates provide a function behavior that can be called for different types: a function
                template represents a family of functions.
              </p>
              <pre><code class="cpp">
template &lt;class T&gt; // T is called the "template parameter"
const T&amp; max(const T&amp; a, const T&amp; b)
{
  return a &lt;b ? a : b;
}
              </code></pre>
              <div class="fragment">
                <p>Or</p>
                <pre><code class="cpp">
template &lt;typename T&gt;
const T&amp; max(const T&amp; a, const T&amp; b)
{
  return a &lt;b ? a : b;
}
                </code></pre>
              </div>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Function templates
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
int main()
{
  int i1 = 3, i2 = 5;
  std::string s1 = "math", s2 = "mathematics";
  double d1 = 2.4, d2 = 4.9;

  std::cout &lt;&lt; ::max(i1, i2) &lt;&lt; std::endl; // 5
  std::cout &lt;&lt; ::max(s1, s2) &lt;&lt; std::endl; // mathematics
  std::cout &lt;&lt; ::max(d1, d2) &lt;&lt; std::endl; // 4.9

  return 0;
}
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Function templates
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;typename T&gt;
const T&amp; max(const T&amp; a, const T&amp; b)
{
  return a &lt;b ? a : b;
}
              </code></pre>
              <pre><code class="cpp">
int res = ::max(3, 5);
              </code></pre>
              <div class="fragment">
                <p>has the semantics of the following code:</p>
                <pre><code class="cpp">
int max(const int&amp; a, const int&amp; b)
{
  return a &lt;b ? a : b;
}
                </code></pre>
              </div>
              <p class="fragment">Replacing template parameters by concrete types is called <i>template instantiation</i>.</p>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Function templates
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
std::complex&lt;double&gt; c1, c2; // complex does not provide operator&lt;
::max(c1, c2);               // ERROR at compile time
              </code></pre>
              <div class ="fragment">
                <p>Templates are compiled twice:</p>
                <ul>
                  <li>Without instantiation, the template code itself is checked for correct syntax.</li>
                  <li>At the time of instantiation, the template code is checked to ensure that all calls are valid.</li>
                </ul>
              </div>
              <p class="fragment">
                The compiler needs the definition of the template at the time of instantiation. This
                breaks the usual split of declaration and definition of ordinary functions.
              </p>
            </div>
          </div>
        </section>
      </section>

      <section>
        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Argument deduction
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;typename T&gt;
const T&amp; max(const T&amp; a, const T&amp; b);

max(4, 7); // OK, T is int for both argument
max(4, 3.2); // ERROR: first T is int, second T is double
              </code></pre>
              <div class="fragment">
                <p>Three ways to handle the error:</p>
                <pre class="fragment"><code class="cpp">
// Cast the arguments:
max(static_cast&lt;double&gt;(4), 3.2);
                </code></pre>
                <pre class="fragment"><code class="cpp">
// Specify explicitly T:
max&lt;double&gt;(4, 3.2);
                </code></pre>
                <pre class="fragment"><code class="cpp">
// Add more template parameters
template &lt;class T1, class T2&gt;
T1 max(const T1&amp; a, const T2&amp; b);
                </code></pre>
              </div>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Argument deduction
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T1, class T2&gt;
T1 max(const T1&amp; a, const T2&amp; b);
// Drawback: the first arugment defines the return type
              </code></pre>
              <div class="fragment">
                <pre><code class="cpp">
template &lt;class RT, clss T1, class T2&gt;
RT max(const T1&amp; a, const T2&amp; b);
// Drawback: RT cannot be deduced:
double d = max&lt;double&gt;(4, 3.2); // OK, T1 and T2 are deduced
                </code></pre>
              </div>
              <div class="fragment">
                <pre><code class="cpp">
template &lt;class RT = T1, class T1, class T2&gt;
RT max(const T1&amp; a, const T2&amp; b);
double d = max(3.2, 4); // OK, T1 and T2 are deduced, RT is defaulted
                </code></pre>
              </div>
              <div class="fragment">
                <pre><code class="cpp">
template &lt;class T1, class T2&gt;
auto max(const T1&amp; a, const T2&amp; b) -&gt; decltype(a+b) {...} // C++11

template &lt;class T1, class T2&gt;
auto max(const T1&amp; a, const T2&amp; b) { ... } // C++14
                </code></pre>
              </div>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Argument deduction
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T&gt;
void f(T t);

template &lt;class T&gt;
void  g(T&amp; t);

int x = 42;
const int cx = 42;
const int&amp; rx = cx;

f(x);  // What is T?
f(cx); // What is T?
f(rx); // What is T?

g(x);  // What is T?
g(cx); // What is T?
g(rx); // What is T?
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Argument deduction
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T&gt;
void f(T t);

f(x);  // x is int, T is int
f(cx); // cx is const int, T is int (const dropped)
f(rx); // rx is const int&amp;, T is const int (reference dropped!)
              </code></pre>
              <pre class="fragment"><code class="cpp">
template &lt;class T&gt;
void  g(T&amp; t);

g(x);  // x is int, T is int
g(cx); // cx is const int, T is const int (const kept)
g(rx); // rx is const int&amp;, T is const int (reference dropped)
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Argument deduction
              </h1>
            </div>
            <div class="main">

              <p>During template type deduction:</p>
              <ul>
                <li>arguments that are references are treated as non-references</li>
                <li>const arguments of by-value parameters are treated as non-const</li>
              </ul>
            </div>
          </div>
        </section>
      </section>

      <section>
        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Overloading function templates
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
inline int max(const int&amp;a const int&amp; b) { ... }

template &lt;class T&gt;
inline T max(const T&amp; a, const T&amp; b) { ... }

template &lt;class T&gt;
inline T max(const T&amp; a, const T&amp; b, const T&amp; c) { ... }
              </code></pre>
              <div class="fragment">
                <p>For each of the following statemnts, which function is called?</p>
                <pre><code class="cpp">
::max(2, 5, 65);
::max(7., 20.);
::max('a', ' b');
::max(7, 42);
::max&lt;&gt;(7, 42);
::max&lt;double&gt;(7, 42);
::max('a', 42.7);
                </code></pre>
              </div>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Overloading function templates
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
inline int max(const int&amp;a const int&amp; b) { ... }

template &lt;class T&gt;
inline T max(const T&amp; a, const T&amp; b) { ... }

template &lt;class T&gt;
inline T max(const T&amp; a, const T&amp; b, const T&amp; c) { ... }
              </code></pre>
              <pre class=fragment><code class="cpp">
::max(2, 5, 65); // calls the template overload taking three arguments
::max(7., 20.);  // calls max&lt;double&gt; (argument deduction)
::max('a', ' b'); // calls max&lt;char&gt; (argument deduction)
              </code></pre>
              <pre class="fragment"><code class="cpp">
::max(7, 42); // Calls the non template overload
              </code></pre>
              <pre class="fragment"><code class="cpp">
::max&lt;&gt;(7, 42); // Calls max&lt;int&gt; (argument deduction)
::max&lt;double&gt;(7, 42); // Calls max&lt;double&gt; (no argument deduction)
              </code></pre>
              <pre class="fragment"><code class="cpp">
::max('a', 42.7); // Calls the non template overload
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Overloading function templates
              </h1>
            </div>
            <div class="main">

              <p>When calling a function with many overloads:</p>
              <ul>
                <li>The compiler will always choose the better match</li>
                <li>All other factors being equals, a non template function is prefered over a template one</li>
                <li>You can force the compiler to choose the template function with the &lt;&gt; syntax</li>
                <li>Only the non template allows different argument types for a same parameter type</li>
              </ul>
            </div>
          </div>
        </section>
      </section>

      <section>
        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Class templates
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T&gt;
class vector
{
  public:

    // C++98: typedef T&amp; reference
    // C++11:
    using reference = T&amp;

    vector();
    vector(const vector&amp; rhs);

    reference operator[](size_t i);
    void push_back(const T&amp; t);

  private:

    T* p_data;
    size_t m_size;
};
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Class templates
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T&gt;
vector&lt;T&gt;::vector() { // ... }

template &lt;class T&gt;
vector&lt;T&gt;::vector(const vector&amp; rhs) { // ... }
              </code></pre>
              <pre class="fragment"><code class="cpp">
template &lt;class T&gt;
typename vector&lt;T&gt;::reference vector&lt;T&gt;::operator[](size_t i)
{
  // ...
}
              </code></pre>
              <pre class="fragment"><code class="cpp">
template &lt;class T&gt;
auto std::vector&lt;T&gt;::operator[](size_t i) -&gt; reference
{
}
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Class templates
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T&gt;
void f(vector&lt;T&gt;&amp; v)
{
  // Typename required:
  using reference = typename vector&lt;T&gt;::reference;
  // no need for typename:
  using double_reference = vector&lt;double&gt;::reference;
}

int main()
{
  vector&lt;double&gt; my_vec;
  f(my_vec);
  return 0;
}
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Class templates
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T&gt;
class my_class
{
  public:

    template&lt;class U&gt;
    void my_func(const U&amp; u);
};

template &lt;class T&gt;
template &lt;class U&gt;
void my_class&lt;T&gt;::my_func(const U&amp; u) { ... }
              </code></pre>
            </div>
          </div>
        </section>
      </section>

      <section>
        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Template specializations
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T1, class T2&gt;
class my_class
{
  public:
    void my_method(const T1&amp; t1, const T2&amp; t2);
};
              </code></pre>
              <pre class="fragment"><code class="cpp">
// Partial specialization
template &lt;class T&gt;
class my_class&lt;double, T&gt;
{
  public:
    void my_method(double t1, const T&amp; t2);
};

template &lt;class T&gt;
void myclass&lt;double, T&gt;::my_method(double t1, const T&amp; t2) { ... }
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Template specializations
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
// Full specialization
template &lt;&gt;
class my_class&lt;int, double&gt;
{
  public:
    void my_method(int t1, double t2);
};
              </code></pre>
              <pre class="fragment"><code class="cpp">
// template&lt;&gt; // no template when defining members of full specialization
void my_class&lt;int, double&gt;::my_method(int t1, double t2) { ... }
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Template specializations
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T1, class T2&gt;
void my_func(T1, T2) { ... }

// OK:
template &lt;&gt;
void my_func&lt;int, double&gt;(int, double) { ... }

// Error:
template &lt;class T&gt;
void my_func&lt;double, T&gt;(double, T) { ... }
              </code></pre>
              <p class="fragment text-center">Function templates support full specialization only</p>
            </div>
          </div>
        </section>
      </section>

      <section>
        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Automatic differentiation - Part 1
              </h1>
            </div>
            <div class="main">

              <p>In autodiff.hpp, define a template class "variable" that:</p>
              <ul>
                <li>Has two members, one for the value, one for the derivative</li>
                <li>Provides two methods to read these members</li>
                <li>Provides a method to "activate" the variable (i.e. setting the derivative to 1)</li>
                <li>Provides a constructor that accepts a single value and initializes the derivative to 0</li>
                <li>Provides a template copy constructor and a template assignment operator</li>
              </ul>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Automatic differentiation - Part 1
              </h1>
            </div>
            <div class="main">

              <ul>
                <li>Implement a template binary_add class that:
                  <ul>
                    <li>Stores its two operands</li>
                    <li>Provides two methods for triggering the computation of the result and its derivative</li>
                  </ul>
                </li>
                <li>Implement a template operator+ that instantiates and returns such a structure</li>
                <li>Implement the template operator+= in the variable class based on the previous one</li>
              </ul>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Automatic differentiation - Part 1
              </h1>
            </div>
            <div class="main">

              <p>What is the issue with the previous design?</p>
              <ul class="fragment">
                <li>Implement a variable_add functor which provides an additional derivative method</li>
                <li>Rename the binary_add structure into binary_op structure</li>
                <li>Add a third template parameter to the structure (the functor describing the operation</li>
                <li>Implement a variable_mul functor</li>
                <li>Implement a template operator* and tempate operator*= for the variable class</li>
              </ul>
            </div>
          </div>
        </section>

      </section>


      <section>
        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Template template parameters
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class E1, class E2&gt;
class binary_add { // ... };

template &lt;class F, class E1, class E2&gt;
class binary_opÂ { // ... };

template &lt;class E1, class E2&gt;
binary_op&lt;binary_add&lt;E1, E2&gt;, E1, E2&gt;
operator+(const E1&amp; e1, const E2&amp; e2)
{
  return binary_op&lt;binary_add&lt;E1, E2&gt;, E1, E2&gt;(e1, e2);
}
              </code></pre>
              <p class="text-center">Passing E1 and E2 to binary_add is cumbersome</p>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Template template parameters
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class E1, class E2&gt;
class binary_add { // ... };

template &lt;template &lt;class, class&gt; class F, class E1, class E2&gt;
class binary_op
{
  public:
    using functor_type = F&lt;E1, E2&gt;
    // ....
};

template &lt;class E1, class E2&gt;
binary_op&lt;binary_add, E1, E2&gt;
operator+(const E1&amp; e1, const E2&amp; e2)
{
  return binary_op&lt;binary_add, E1, E2&gt;(e1, e2);
}
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Traits
              </h1>
            </div>
            <div class="main">

              <p>Traits are</p>
              <ul>
                <li>small structures providing information about types</li>
                <li>basics blocks of template metaprogramming</li>
              </ul>
              <p>the standard header type_traits defines a lot of them (see documentation on cppreference.com)</p>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Traits
              </h1>
            </div>
            <div class="main">

              <p>Implementation pattern:</p>
              <pre><code class="cpp">
template &lt;class T&gt;
struct add_reference
{
  using reference = T&amp;
};

// Specialization of add_reference for reference types
template &lt;class T&gt;
struct add_reference&lt;T&amp;&gt;
{
  using reference = T&amp;
};

template &lt;class T&gt;
using add_reference_t = typename add_reference&lt;T&gt;::type;
              </code></pre>
              <pre class="fragment"><code class="cpp">
template &lt;class T&gt;
class my_vector
{
  using reference = add_reference_t&lt;T&gt;;
};
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Traits
              </h1>
            </div>
            <div class="main">

              <ul>
                <li>using declarations cannot be specialized</li>
                <li>using declarations can be used without typename</li>
                <li>structures can be specialized</li>
                <li>structures requires to access an inner defined type, typename is required</li>
              </ul>
              <p class="fragment">We combine them to get the best of two approaches</p>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Automatic differentiation - Part 1
              </h1>
            </div>
            <div class="main">

              <p>We want to store the variables by references and the operation structure by value.</p>
              <ul>
                <li>Implement a structure is_variable that defines an inner type as
                    <ul>
                      <li>std::false_type when its template parameter is NOT a variable</li>
                      <li>std::true_type otherwise</li>
                    </ul>
                <li>Implement a storage_type structure that defines an inner type as
                    <ul>
                      <li>its template parameter when it's not a variable</li>
                      <li>a const reference to its template parameter when it's a variable</li>
                    </ul>
                </li>
              </ul>
            </div>
          </div>
        </section>


      </section>

      <section>
        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Automatic differentiation - Part 2
              </h1>
            </div>
            <div class="main">

              <ul>
                <li>Implement a unary_op structure, similar to binary_op</li>
                <li>Implement functors for common math functions (exp, log)</li>
                <li>Implement a template sigmoid function</li>
                <li>Use your classes to compute both value and derivatives of the sigmoid</li>
              </ul>
              <p class="fragment">What is the issue with this design?</p>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Variadic templates
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class... T&gt;
class universal_op
{
  public:
  using operands_types = std::tuple&lt;T...&gt;;
};
              </code></pre>
              <div class="fragment">
                <pre><code class="cpp">
universal_op&lt;int, double, float&gt; u; // parameter pack is (int, double, float)
universal_op&lt;int&gt; u;                // parameter pack is (int)
universal_op&lt;&gt; u;                   // OK, parameter pack is empty
                </code></pre>
              </div>
              <div class="fragment">
                <pre><code class="cpp">
template &lt;class... T, class E1&gt;
class invalid {};
                </code></pre>
                <p class="text-center">The parameter pack must be the last template parameter</p>
              </div>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Variadic templates
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class... T&gt;
void my_func(T... args)
{
  call_func(args...);
}

template &lt;class... T&gt;
void my_other_func(const T&amp;... args)
{
  call_other_func(args...);
}
              </code></pre>
              <p class="fragment text-center">What if I want to pass some arguments by reference and other by values?</p>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Universal references
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T&gt;
void my_func(T&amp;&amp; t) { ... }

int x = 42;
int&amp; rx = x;
const int&amp; cx = x;

// For the following calls, what is T? what is the type of the argument of my_func?
my_func(x);
my_func(rx);
my_func(cx);
my_func(std::move(x));
my_func(42);
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Universal references
              </h1>
            </div>
            <div class="main">

              <p>During template type deduction with universal references:</p>
              <ul>
                <li>arguments that are references are treated as references</li>
                <li>T&amp; &amp;&amp; collapses to T&amp;</li>
                <li>T&amp;&amp; &amp;&amp; collapses to T&amp;&amp;</li>
              </ul>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Universal references
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T&gt;
void my_func(T&amp;&amp; t) { ... }

int x = 42;
int&amp; rx = x;
const int&amp; cx = x;

my_func(x);   // T is int&amp; - param type is int&amp;
my_func(rx);  // T is int&amp; - param type is int&amp;
my_func(cx);  // T is const int&amp; - param type is const int&amp;
my_func(std::move(x)); // T is const int&amp;&amp; - param type is const int&amp;&amp;
my_func(42);  // T is int - param type is int&amp;&amp;
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Universal references
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T&gt;
void my_func(T&amp;&amp; t); // universal reference

tempate &lt;class T&gt;
void my_func(std::vector&lt;T&gt;&amp;&amp; v); // rvalue reference
              </code></pre>
              <p class="fragment text-center">Universal reference only for deduced types</p>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Universal references
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class T&gt;
void my_func_impl(T&amp;&amp; t) { ... }

template &lt;class T&gt;
void my_func(T&amp;&amp; t)
{
  // calling my_func_impl with lvalue, wrong if t was an rvalue reference,
  my_func_impl(t);
  // calling my_func_impl with rvalue, wrong if t was an lvalue
  my_func_impl(std::move(t));
}
              </code></pre>
              <pre class="fragment"><code class="cpp">
template &lt;class T&gt;
void my_func(T&amp;&amp; t)
{
  my_func_impl(std::forward&lt;T&gt;(t));
}
              </code></pre>
              <p class="fragment text-center">std::forward allows to achieve <i>perfect forwarding</i></p>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Universal references
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class... T&gt;
void my_func(T&amp;&amp;... args)
{
  // Forwards each argument, i.e. keeps the
  // lvalue-ness or rvalue-ness of each argument
  // indepently from other arguments
  call_func(std::forward&lt;T&gt;(args)...);
}
              </code></pre>
            </div>
          </div>
        </section>
      </section>

      <section>
        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Curiously Recurring Template Pattern (CRTP)
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class... T&gt;
class universal_op;

template &lt;class T&gt;
class variable;

template &lt;class E&gt;
universal_op&lt;exp, E&gt; exp(const E&amp; e)
{
  return universal_op&lt;exp, E&gt;(e);
}
              </code></pre>
              <p>exp catches any type wihle we would like to catch universal_op and variables only</p>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">
                Curiously Recurring Template Pattern (CRTP)
              </h1>
            </div>
            <div class="main">

              <pre><code class="cpp">
template &lt;class D&gt;
class expression
{
  public:
    D&amp; operator()() { return *static_cast&lt;D*&gt;(this); }
    const D&amp; operator()() const { return *static_cast&lt;const D*&gt;(this); }
};

template &lt;class T&gt;
class variable : public expression&lt;variable&lt;T&gt;&gt;
{ // ... };

template &lt;class... T&gt;
class universal_op : public expression&lt;universal_op&lt;T...&gt;&gt;
{ // ... };

template &lt;class E&gt;
universal_op&lt;exp, E&gt; exp(const expression&lt;E&gt;&amp; e)
{
  return universal_op&lt;exp, E&gt;(e());
}
              </code></pre>
              <p class="text-center">CRTP implements static polymorphism</p>
            </div>
          </div>
        </section>
      </section>

    </div>
  </div>
  <script type="module" src="/main.js"></script>
</body>

</html>
