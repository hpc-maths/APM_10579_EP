<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/styles.css">
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css"> -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

  <title>MAP586 - Object Oriented Programming</title>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section class="title">
        <h1>MAP 586</h1>
        <h2>Templates</h2>
      </section>

      <section>
        <section>
          <h1>Why templates ?</h1>
          <pre><code class="cpp">
int min(int a, int b)
{
    return a &lt; b ? a : b;
}

double min(double a, double b)
{
    return a &lt; b ? a : b;
}
          </code></pre>
          <p>Same code for every arithmetic type</p>
        </section>

        <section>
          <h1>Possible solutions (1/3)</h1>
          <p>Use C macros</p>
          <pre><code class="cpp">
#define DEFINE_MIN(TYPE)        \
    TYPE min(TYPE a, TYPE b)    \
    {                           \
        return a &lt;b ? a : b;    \
    }

DEFINE_MIN(int)
DEFINE_MIN(double)
DEFINE_MIN(float)
....
#undef min
          </code></pre>
        </section>
        <section>
          <h1>Possible solutions (2/3)</h1>
          <p> Use a common base class for all types</p>
            <pre><code class="cpp">
const object&amp; min(const object&amp; a, const object&amp; b)
{
    return a.less_than(b) ? a : b;
}
            </code></pre>
          <ul>
            <li>limited type checking</li>
            <li>No more value semantics (because of inheritance)</li>
          </ul>
        </section>
        
        <section>
          <h1>Possible solutions (3/3)</h1>
          <p>C++ templates: similar to C macros, but have it generated by the compiler</p>          
          <ul>
            <li>No need to write additional code for new types</li>
            <li>No need to inherit for a common base class</li>
            <li>Full type checking</li>
          </ul>
        </section>
      </section>

      <section>
        <section>
          <h1>Function templates</h1>
          <p>Function templates provide a function behavior that can be called for different types: a function
          template represents a family of functions.</p>
          <pre><code class="cpp">
template &lt;class T&gt; // T is called the "template parameter"
const T&amp; max(const T&amp; a, const T&amp; b)
{
    return a &lt;b ? a : b;
}
          </code></pre>
          <div class="fragment">
            <p>Or</p>
            <pre><code class="cpp">
template &lt;typename T&gt;
const T&amp; max(const T&amp; a, const T&amp; b)
{
    return a &lt;b ? a : b;
}
            </code></pre>
          </div>
        </section>

        <section>
          <h1>Function templates</h1>
          <pre><code class="cpp">
int main()
{
    int i1 = 3, i2 = 5;
    std::string s1 = "math", s2 = "mathematics";
    double d1 = 2.4, d2 = 4.9;

    std::cout &lt;&lt; ::max(i1, i2) &lt;&lt; std::endl; // 5
    std::cout &lt;&lt; ::max(s1, s2) &lt;&lt; std::endl; // mathematics
    std::cout &lt;&lt; ::max(d1, d2) &lt;&lt; std::endl; // 4.9

    return 0;
}
          </code></pre>
        </section>
        
        <section>
          <h1>Function templates</h1>
          <pre><code class="cpp">
template &lt;typename T&gt;
const T&amp; max(const T&amp; a, const T&amp; b)
{
    return a &lt;b ? a : b;
}
          </code></pre>
          <pre><code class="cpp">
int res = ::max(3, 5);
          </code></pre>
          <div class="fragment">
            <p>has the semantics of the following code:</p>
            <pre><code class="cpp">
int max(const int&amp; a, const int&amp; b)
{
    return a &lt;b ? a : b;
}
            </code></pre>
          </div>
          <p class="fragment">Replacing template parameters by concrete types is called <i>template instantiation</i></p>
        </section>
        
        <section>
          <h1>Function templates</h1>
          <pre><code class="cpp">
std::complex&lt;double&gt; c1, c2; // complex does not provide operator&lt;
::max(c1, c2);               // ERROR at compile time
          </code></pre>
          <div class ="fragment">
            <p>Templates are compiled twice:</p>
            <ul>
              <li>Without instantiation, the template code itself is chacked for correct syntax</li>
              <li>At the time of instantiation, the template code is checked to ensure that all calls are valid.</li>
            </ul>
          </div>
          <p class="fragment">The compiler needs the definition of the template at the time of instantiation. This
          breaks the usual split of declaration and definition of ordinary functions.</p>
        </section>
      </section>

      <section>
        <section>
          <h1>Argument deduction</h1>
          <pre><code class="cpp">
template &lt;typename T&gt;
const T&amp; max(const T&amp; a, const T&amp; b);

max(4, 7); // OK, T is int for both argument
max(4, 3.2); // ERROR: first T is int, second T is double 
          </code></pre>
          <div class="fragment">
            <p>Three ways to handle the error:</p>
            <pre class="fragment"><code class="cpp">
// Cast the arguments:
max(static_cast&lt;double&gt;(4), 3.2);
            </code></pre>
            <pre class="fragment"><code class="cpp">
// Specify explicitly T:
max&lt;double&gt;(4, 3.2);
            </code></pre>
            <pre class="fragment"><code class="cpp">
// Add more template parameters
template &lt;class T1, class T2&gt;
T1 max(const T1&amp; a, const T2&amp; b);
            </code></pre>
          </div>
        </section>
        
        <section>
          <h1>Argument deduction</h1>
          <pre><code class="cpp">
template &lt;class T1, class T2&gt;
T1 max(const T1&amp; a, const T2&amp; b);
// Drawback: the first arugment defines the return type
          </code></pre>
          <div class="fragment">
            <pre><code class="cpp">
template &lt;class RT, clss T1, class T2&gt;
RT max(const T1&amp; a, const T2&amp; b);
// Drawback: RT cannot be deduced:
double d = max&lt;double&gt;(4, 3.2); // OK, T1 and T2 are deduced
            </code></pre>
          </div>
          <div class="fragment">
            <pre><code class="cpp">
template &lt;class RT = T1, class T1, class T2&gt;
RT max(const T1&amp; a, const T2&amp; b);
double d = max(3.2, 4); // OK, T1 and T2 are deduced, RT is defaulted
            </code></pre>
          </div>
          <div class="fragment">
            <pre><code class="cpp">
template &lt;class T1, class T2&gt;
auto max(const T1&amp; a, const T2&amp; b) -&gt; decltype(a+b) {...} // C++11

template &lt;class T1, class T2&gt;
auto max(const T1&amp; a, const T2&amp; b) { ... } // C++14
            </code></pre>
          </div>
        </section>

        <section>
          <h1>Argument deduction</h1>
          <pre><code class="cpp">
template &lt;class T&gt;
void f(T t);

template &lt;class T&gt;
void  g(T&amp; t);

int x = 42;
const int cx = 42;
const int&amp; rx = cx;

f(x);  // What is T?
f(cx); // What is T?
f(rx); // What is T?

g(x);  // What is T?
g(cx); // What is T?
g(rx); // What is T?
          </code></pre>
        </section>

        <section>
          <h1>Argument deduction</h1>
          <pre><code class="cpp">
template &lt;class T&gt;
void f(T t);

f(x);  // x is int, T is int
f(cx); // cx is const int, T is int (const dropped)
f(rx); // rx is const int&amp;, T is const int (reference dropped!)
          </code></pre>
          <pre class="fragment"><code class="cpp">
template &lt;class T&gt;
void  g(T&amp; t);

g(x);  // x is int, T is int
g(cx); // cx is const int, T is const int (const kept)
g(rx); // rx is const int&amp;, T is const int (reference dropped)
          </code></pre>
        </section>

        <section>
          <h1>Argument deduction</h1>
          <p>During template type deduction:</p>
          <ul>
            <li>arguments that are references are treated as non-references</li>
            <li>const arguments of by-value parameters are treated as non-const</li>
          </ul>
        </section>
      </section>
      <section>        
        <section>
          <h1>Overloading function templates</h1>
          <pre><code class="cpp">
inline int max(const int&amp;a const int&amp; b) { ... }

template &lt;class T&gt;
inline T max(const T&amp; a, const T&amp; b) { ... }

template &lt;class T&gt;
inline T max(const T&amp; a, const T&amp; b, const T&amp; c) { ... }
          </code></pre>
          <div class="fragment">
            <p>For each of the following statemnts, which function is called?</p>
            <pre><code class="cpp">
::max(2, 5, 65);
::max(7., 20.);
::max('a', ' b');
::max(7, 42);
::max&lt;&gt;(7, 42);
::max&lt;double&gt;(7, 42);
::max('a', 42.7);
            </code></pre>
          </div>
        </section>

        <section>
          <h1>Overloading function templates</h1>
          <pre><code class="cpp">
inline int max(const int&amp;a const int&amp; b) { ... }

template &lt;class T&gt;
inline T max(const T&amp; a, const T&amp; b) { ... }

template &lt;class T&gt;
inline T max(const T&amp; a, const T&amp; b, const T&amp; c) { ... }
          </code></pre>
          <pre class=fragment><code class="cpp">
::max(2, 5, 65); // calls the template overload taking three arguments
::max(7., 20.);  // calls max&lt;double&gt; (argument deduction)
::max('a', ' b'); // calls max&lt;char&gt; (argument deduction)
          </code></pre>
          <pre class="fragment"><code class="cpp">
::max(7, 42); // Calls the non template overload
          </code></pre>
          <pre class="fragment"><code class="cpp">
::max&lt;&gt;(7, 42); // Calls max&lt;int&gt; (argument deduction)
::max&lt;double&gt;(7, 42); // Calls max&lt;double&gt; (no argument deduction)
          </code></pre>
          <pre class="fragment"><code class="cpp">
::max('a', 42.7); // Calls the non template overload
          </code></pre>
        </section>

        <section>
          <h1>Overloading function templates</h1>
          <p>When calling a function with many overloads:</p>
          <ul>
            <li>The compiler will always choose the better match</li>
            <li>All other factors being equals, a non template function is prefered over a template one</li>
            <li>You can force the compiler to choose the template function with the &lt;&gt; syntax</li>
            <li>Only the non template allows different argument types for a same parameter type</li>
          </ul>
        </section>
      </section>
      
      <section>
        <section>
          <h1>Class templates</h1>
          <pre><code class="cpp">
template &lt;class T&gt;
class vector
{
public:

    // C++98: typedef T&amp; reference
    // C++11:
    using reference = T&amp;

    vector();
    vector(const vector&amp; rhs);

    reference operator[](size_t i);
    void push_back(const T&amp; t);

private:

    T* p_data;
    size_t m_size;
};
          </code></pre>
        </section>

        <section>
          <h1>Class templates</h1>
          <pre><code class="cpp">
template &lt;class T&gt;
vector&lt;T&gt;::vector() { // ... }

template &lt;class T&gt;
vector&lt;T&gt;::vector(const vector&amp; rhs) { // ... }
          </code></pre>
          <pre class="fragment"><code class="cpp">
template &lt;class T&gt;
typename vector&lt;T&gt;::reference vector&lt;T&gt;::operator[](size_t i)
{
    // ...
}
          </code></pre>
          <pre class="fragment"><code class="cpp">
template &lt;class T&gt;
auto std::vector&lt;T&gt;::operator[](size_t i) -&gt; reference
{
}
          </code></pre>
        </section>

        <section>
          <h1>Class templates</h1>
          <pre><code class="cpp">
template &lt;class T&gt;
void f(vector&lt;T&gt;&amp; v)
{
    // Typename required:
    using reference = typename vector&lt;T&gt;::reference;
    // no need for typename:
    using double_reference = vector&lt;double&gt;::reference;
}

int main()
{
    vector&lt;double&gt; my_vec;
    f(my_vec);
    return 0;
}
          </code></pre>
        </section>

        <section>
          <h1>Class templates</h1>
          <pre><code class="cpp">
template &lt;class T&gt;
class my_class
{
public:

    template&lt;class U&gt;
    void my_func(const U&amp; u);
};

template &lt;class T&gt;
template &lt;class U&gt;
void my_class&lt;T&gt;::my_func(const U&amp; u) { ... }
          </code></pre>
        </section>
      </section>

      <section>
        <section>
          <h1>Template specializations</h1>
          <pre><code class="cpp">
template &lt;class T1, class T2&gt;
class my_class
{
public:
    void my_method(const T1&amp; t1, const T2&amp; t2);
};
          </code></pre>
          <pre class="fragment"><code class="cpp">
// Partial specialization
template &lt;class T&gt;
class my_class&lt;double, T&gt;
{
public:
    void my_method(double t1, const T&amp; t2);
};

template &lt;class T&gt;
void myclass&lt;double, T&gt;::my_method(double t1, const T&amp; t2) { ... }
          </code></pre>
        </section>

        <section>
          <h1>Template specializations</h1>
          <pre><code class="cpp">
// Full specialization
template &lt;&gt;
class my_class&lt;int, double&gt;
{
public:
    void my_method(int t1, double t2);
};

          </code></pre>
          <pre class="fragment"><code class="cpp">
// template&lt;&gt; // no template when defining members of full specialization
void my_class&lt;int, double&gt;::my_method(int t1, double t2) { ... }
          </code></pre>
        </section>

        <section>
          <h1>Template specializations</h1>
          <pre><code class="cpp">
template &lt;class T1, class T2&gt;
void my_func(T1, T2) { ... }

// OK:
template &lt;&gt;
void my_func&lt;int, double&gt;(int, double) { ... }

// Error:
template &lt;class T&gt;
void my_func&lt;double, T&gt;(double, T) { ... }  
          </code></pre>
          <p class="fragment">Function templates support full specialization only</p>
        </section>
      </section>

    <section>
      <section>
        <h1>Automatic differentiation</h1>
        <p>In autodiff.hpp, define a template class "variable" that:</p>
        <ul>
          <li>Has two members, one for the value, one for the derivative</li>
          <li>Provides two methods to read these members</li>
          <li>Provides a method to "activate" the variable (i.e. setting the derivative to 1)</li>
          <li>Provides a constructor that accepts a single value and initializes the derivative to 0</li>
          <li>Provides a template copy constructor and a template assignment operator</li>
        </ul>
      </section>

      <section>
        <h1>Automatic differentiation</h1>
        <ul>
          <li>Implement a template binary_add class that:
            <ul>
              <li>Stores its two operands</li>
              <li>Provides two methods for triggering the computation of the result and its derivative</li>
            </ul>
          </li>
          <li>Implement a template operator+ that instantiates and returns such a structure</li>
          <li>Implement the template operator+= in the variable class based on the previous one</li>
        </ul>
      </section>

      <section>
        <h1>Automatic differentiation</h1>
        <p>What is the issue with the previous design?</p>
        <ul class="fragment">
          <li>Implement a variable_add functor which provides an additional derivative method</li>
          <li>Rename the binary_add structure into binary_op structure</li>
          <li>Add a third template parameter to the structure (the functor describing the operation</li>
          <li>Implement a variable_mul functor</li>
          <li>Implement a template operator* and tempate operator*= for the variable class</li>
        </ul>
      </section>

      <section>
        <h1>Automatic differentiation</h1>
        <ul>
          <li>Implement a unary_op structure, similar to binary_op</li>
          <li>Implement functors for common math functions (exp, log)</li>
          <li>Implement a template sigmoid function</li>
          <li>Use your classes to compute both value and derivatives of the sigmoid</li>
        </ul>
      </section>

    </section>
    
    </div>
  </div>
  <script type="module" src="/main.js"></script>
</body>

</html>
