<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/theme/dark.css" id="theme">
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
      crossorigin="anonymous">

    <title>APM_50179_EP - Polymorphism</title>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

        <section class="title-section">
          <h1>
            Polymorphism
          </h1>
          <h2>
            APM 50179 EP
          </h2>
        </section>

        <section>
          <section class="slide">
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Inheritance
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// In interpolation_impl.hpp

class interpolation_impl
{
  public:
};

class linear_interpolation : public interpolation_impl
{
};

class spline_interpolation : public interpolation_impl
{
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Inheritance
                </h1>
              </div>
              <div class="main">

                <ul>
                  <li>Add a method <strong>interpolate</strong> to the
                    <strong>interpolation_impl</strong> class.</li>
                  <li>This method should accept a <strong>double</strong> and
                    return <strong>0</strong>.</li>
                  <li>Uncomment the <strong>test_accessibility1</strong> in
                    main.cpp.</li>
                  <li>Uncomment the call to <strong>test_accessibility1</strong>
                    in main function.</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Inheritance
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// intterpolation_impl.hpp
class interpolation_impl
{
  public:

    double interpolate(double x) const;
};
</code></pre>
                <pre><code class="cpp">
// interpolation_impl.cpp
double interpolation_impl::interpolate(double x) const
{
  return 0;
}
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Inheritance
                </h1>
              </div>
              <div class="main">

                <ul>
                  <li>Add two members <strong>m_x</strong> and
                    <strong>m_y</strong> of type
                    <strong>std::vector&lt;double&gt;</strong> to the private
                    section of interpolation_impl.</li>
                  <li>Add a constructor that accepts two vectors and initializes
                    those data members.</li>
                  <li>Fix the constructor of the inheriting classes.</li>
                  <li>Use the <strong>get_test_spline_interpolation</strong>
                    function in test_accessibility1 to fix the build.</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Inheritance
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl.hpp
class interpolation_impl
{
  public:

    interpolation_impl(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

    double interpolate(double x) const;

  private:

    std::vector&lt;double&gt; m_x;
    std::vector&lt;double&gt; m_y;
};

class spline_interpolation : public interpolation_impl
{
  public:

    spline_interpolation(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Inheritance
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl.cpp
interpolation_impl::interpolation_impl(const std::vector&lt;double&gt;&amp; x,
const std::vector&lt;double&gt;&amp; y)
: m_x(x)
, m_y(y)
{
}

spline_interpolation::spline_interpolation(const std::vector&lt;double&gt;&amp; x,
const std::vector&lt;double&gt;&amp; y)
: interpolation_impl(x, y)
{
}
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Inheritance
                </h1>
              </div>
              <div class="main">

                <ul>
                  <li>Add a <strong>m_y2</strong> vector member to the
                    <strong>spline_interpolation</strong> class.</li>
                  <li>Initialize it in the constructor thanks to the
                    <strong>spline_derivative</strong> method.</li>
                  <li>Try to use the data members of the mother class as
                    arguments of <strong>spline_derivative</strong>.</li>
                  <li>What do you notice?</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Inheritance
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl.hpp
class spline_interpolation : public interpolation_impl
{
  public:

    spline_interpolation(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

  private:

    std::vector&lt;double&gt; m_y2;
};
              </code></pre>
                <pre><code class="cpp">
// interpolation_impl.cpp
spline_interpolation::spline_interpolation(const std::vector&lt;double&gt;&amp; x,
const std::vector&lt;double&gt;&amp; y)
: interpolation_impl(x, y)
, m_y2(x.size())
{
  spline_derivative(x, y, m_y2);       // OK
  //spline_derivative(m_x, m_y, m_y2); // Fails
}
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Inheritance
                </h1>
              </div>
              <div class="main">

                <ul>
                  <li><strong>public</strong>: access granted to everyone</li>
                  <li><strong>private</strong>: access granted to class
                    only</li>
                  <li><strong>protected</strong>: access granted to class and
                    inheriting classes</li>
                </ul>
                <p class="fragment text-center">Avoid putting data in the
                  protected section, prefer methods</p>
                <p class="fragment text-center">Fix the
                  <strong>interpolation_impl</strong> and
                  <strong>spline_interpolation</strong> classes</p>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Inheritance
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl.hpp
class interpolation_impl
{
  public:

    interpolation_impl(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

    double interpolate(double x) const;

  protected:

    const std::vector&lt;double&gt;&amp; get_x() const;
    const std::vector&lt;double&gt;&amp; get_y() const;

  private:

    std::vector&lt;double&gt; m_x;
    std::vector&lt;double&gt; m_y;
};
              </code></pre>
              </div>
            </div>
          </section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Inheritance
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl.cpp
const std::vector&lt;double&gt;&amp; interpolation_impl::get_x() const
{
  return m_x;
}

const std::vector&lt;double&gt;&amp; interpolation_impl::get_y() const
{
  return m_y;
}

spline_interpolation::spline_interpolation(const std::vector&lt;double&gt;&amp; x,
const std::vector&lt;double&gt;&amp; y)
: interpolation_impl(x, y)
, m_y2(x.size())
{
  spline_derivative(get_x(), get_y(), m_y2);
}
              </code></pre>
              </div>
            </div>
          </section>
        </section>

        <section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Polymorphism
                </h1>
              </div>
              <div class="main">

                <ul>
                  <li>Override the <strong>interpolate</strong> method in the
                    <strong>spline_interpolation</strong> class, it should
                    return 1.</li>
                  <li>Uncomment the two <strong>test_polymorphism</strong>
                    functions in main.cpp.</li>
                  <li>Uncomment the call to <strong>test_polymorphism</strong>
                    from the main function.</li>
                  <li>Run the program.</li>
                  <li>What do you notice?</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Polymorphism
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// inteprolation_impl.hpp
class spline_interpolation : public interpolation_impl
{
  public:

    spline_interpolation(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

    double interpolate(double x) const;

  private:

    std::vector&lt;double&gt; m_y2;
};
              </code></pre>
                <pre><code class="cpp">
// interpolation_impl.cpp
double spline_interpolation::interpolate(double x) const
{
  return 1.;
}
              </code></pre>
              </div>
            </div>
          </section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Polymorphism
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl.hpp
class interpolation_impl
{
  public:

    interpolation_impl(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

    virtual double interpolate(double x) const;

  // as before ...
};
              </code></pre>
              </div>
            </div>
          </section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Polymorphism
                </h1>
              </div>
              <div class="main">

                <p><strong>virtual</strong></p>
                <ul>
                  <li>is not part of the signature,</li>
                  <li>implies each overload in inheriting classes is virtual
                    too,</li>
                  <li>does not prevent to declare such overload as virtual,</li>
                  <li>does not force inheriting classes to declare such
                    overload.</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Polymorphism
                </h1>
              </div>
              <div class="main">

                <p>Add a <strong>size_t</strong> argument to the overload method
                  in <strong>spline_interpolation</strong> and run the program
                  again:</p>
                <div class="fragment">
                  <pre><code class="cpp">
// interpolation_impl.hpp
class spline_interpolation : public interpolation_impl
{
  public:

    spline_interpolation(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

    // Defines a new method interpolate that is not an override of
    // interpolate declared in the base class
    double interpolate(double x, size_t i) const;

  // As before ...
};
                </code></pre>
                  <pre><code class="cpp">
// interpolation_impl.cpp
double spline_interpolation::interpolate(double x, size_t i) const
{
  return 1.;
}
                </code></pre>
                </div>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Polymorphism
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl.hpp
class spline_interpolation : public interpolation_impl
{
  public:

    spline_interpolation(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

    // Error, no interpolate(double, size_t) declared in base class
    double interpolate(double x, size_t i) const override;
    // Ok, override interpolate(double) declared in base class
    double interpolate(double x) const override;

  // As before ...
};
              </code></pre>
                <ul class="fragment">
                  <li>Remove the <strong>size_t</strong> parameter in
                    <strong>spline_interpolation::interpolate</strong>.</li>
                  <li>Use <strong>override</strong> to prevent future
                    mistake.</li>
                </ul>
              </div>
            </div>
          </section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Polymorphism
                </h1>
              </div>
              <div class="main">

                <p><strong>override</strong></p>
                <ul>
                  <li>is not part of the signature,</li>
                  <li>requires the method to be declared in the base class with
                    the same signature.</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Polymorphism
                </h1>
              </div>
              <div class="main">

                <ul>
                  <li>Uncomment the <strong>get_test_interpolation</strong>
                    function in main.cpp.</li>
                  <li>Remove the definition of
                    <strong>interpolation_impl::interpolate</strong> from
                    interpolation_impl.cpp.</li>
                  <li>Change the declaration of
                    <strong>interpolation_impl::interpolate</strong>:
                    <pre><code class="cpp">
// interpolation_impl.hpp
class interpolation_impl
{
  public:

    interpolation_impl(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

    virtual double interpolate(double x) const = 0;

  // as before ...
};

                  </code></pre>
                  </li>
                  <li>Try to build.</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Polymorphism
                </h1>
              </div>
              <div class="main">

                <p>An <strong>abstract class</strong></p>
                <ul>
                  <li>Has at least one pure virtual method.</li>
                  <li>Cannot be instantiated.</li>
                  <li>An inheriting class that does not implement all abstract
                    methods is abstract.</li>
                </ul>
              </div>
            </div>
          </section>
        </section>

        <section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <ul>
                  <li>Add <strong>destructors</strong> to interpolation_impl and
                    spline_interpolation.</li>
                  <li>Add <strong>logs</strong> (i.e. std::cout) in each
                    constructor and destructor.</li>
                  <li>Uncomment the <strong>test_polymorphism1</strong> function
                    and its call in the main function.</li>
                  <li>Build and run.</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl.hpp
class interpolation_impl
{
  public:

    interpolation_impl(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

    ~interpolation_impl();

  // ... as before
};

class spline_interpolation : public interpolation_impl
{
  public:

    spline_interpolation(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

    ~spline_interpolation();

  // ... as before
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl.cpp
interpolation_impl::interpolation_impl(const std::vector&lt;double&gt;&amp; x,
const std::vector&lt;double&gt;&amp; y)
: m_x(x)
, m_y(y)
{
  std::cout &lt;&lt; "interpolation_impl constructor" &lt;&lt; std::endl;
}

interpolation_impl::~interpolation_impl()
{
  std::cout &lt;&lt; "interpolation_impl destructor" &lt;&lt; std::endl;
}

spline_interpolation::spline_interpolation(const std::vector&lt;double&gt;&amp; x,
const std::vector&lt;double&gt;&amp; y)
: interpolation_impl(x, y)
, m_y2(x.size())
{
  spline_derivative(get_x(), get_y(), m_y2);
  std::cout &lt;&lt; "spline_interpolation constructor" &lt;&lt; std::endl;
}

spline_interpolation::~splint_interpolation()
{
  std::cout &lt;&lt; "spline_interplation destructor" &lt;&lt; std::endl;
}
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl.hpp
class interpolation_impl
{
  public:

    interpolation_impl(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

    virtual ~interpolation_impl();

  // ... as before
};

class spline_interpolation : public interpolation_impl
{
  public:

    spline_interpolation(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);

    virtual ~spline_interpolation();

  // ... as before
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <ul>
                  <li>Add a virtual method <strong>print</strong> to each class,
                    that prints all the members.</li>
                  <li>You can use the <strong>print_vector</strong> function to
                    implement it.</li>
                  <li>Uncomment the <strong>test_assign</strong> function and
                    its call in main.</li>
                  <li>Build and run the program, what do you notice?</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl/hpp
class interpolation_impl
{
  public:

    virtual void print() const;
  // as before ...
};

class spline_interpolation : public interpolation_impl
{
  public:

    virtual void print() const;
  // as before ...
};
              </code></pre>
                <pre><code class="cpp">
// interpolation_impl.cpp
void interpolation_impl::print() const
{
  print_vector("m_x", m_x);
  print_vector("m_y", m_y);
}

void spline_interpolation::print() const
{
  interpolation_impl::print();
  print_vector("m_y2", m_y2);
}
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <ul>
                  <li>Incomplete assignment due to inheritance is called
                    <strong>slicing</strong>.</li>
                  <li>Constructors and assignment operators cannot be
                    virtual.</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class interpolation_impl
{
  public:

    interpolation_impl(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);
    virtual ~interpolation_impl() = default;

    interpolation_impl(const interpolation_impl&amp;);
    interpolation_impl&amp; operator=(const interpolation_impl&amp;);
    interpolation_impl(interpolation_impl&amp;&amp;);
    interpolation_impl&amp; operator=(interpolation_impl&amp;&amp;);
};
              </code></pre>
                <p class="fragment text-center">DON'T.DO.THAT</p>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <p>Prevent users to call copy / move constructor / assign
                  operator</p>
                <pre class="fragment"><code class="cpp">
class interpolation_impl
{
  public:

    interpolation_impl(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);
    virtual ~interpolation_impl() = default;

    interpolation_impl(const interpolation_impl&amp;) = delete;
    interpolation_impl&amp; operator=(const interpolation_impl&amp;) = delete;
    interpolation_impl(interpolation_impl&amp;&amp;) = delete;
    interpolation_impl&amp; operator=(interpolation_impl&amp;&amp;) = delete;

  // as before ...
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <p>Prevent instantiation of base class</p>
                <pre class="fragment"><code class="cpp">
class interpolation_impl
{
  public:

    virtual ~interpolation_impl() = default;

    interpolation_impl(const interpolation_impl&amp;) = delete;
    interpolation_impl&amp; operator=(const interpolation_impl&amp;) = delete;
    interpolation_impl(interpolation_impl&amp;&amp;) = delete;
    interpolation_impl&amp; operator=(interpolation_impl&amp;&amp;) = delete;

  // as before ...

  protected:

    interpolation_impl(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <p>How to copy an instance of spline_interpolation</p>
                <pre class="fragment"><code class="cpp">
class interpolation_impl
{
  public:

  virtual interpolation_impl* clone() const = 0;
  // as before ...
};

class spline_interpolation : public interpolation_impl
{
  public:

  spline_interpolation* clone() const override;
};
              </code></pre>
              </div>
            </div>
          </section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
spline_interplation* spline_interpolation::clone() const
{
  return new spline_interpolation(get_x(), get_y());
}
              </code></pre>
                <pre class="fragment"><code class="cpp">
spline_interplation* spline_interpolation::clone() const
{
  // This actually needs the copy constructor
  return new spline_interpolation(*this);
}
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class interpolation_impl
{
  public:

    virtual ~interpolation_impl() = default;

    interpolation_impl&amp; operator=(const interpolation_impl&amp;) = delete;
    interpolation_impl(interpolation_impl&amp;&amp;) = delete;
    interpolation_impl&amp; operator=(interpolation_impl&amp;&amp;) = delete;

    virtual interpolation_impl* clone() const = 0;
    // as before ...

  protected:

    interpolation_impl(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);
    interpolation_impl(const interpolation_impl&amp;);

    // as before ...
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class spline_interpolation : public interpolation_impl
{
  public:

    spline_interpolation(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y);
    virtual ~spline_interpolation();

    spline_interpolation* clone() const override;

    // as before ...

  protected:

    spline_interpolation(const spline_interpolation&amp;);

    // as before ...
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Entity semantics
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
interpolation_impl::interpolation_impl(const interpolation_impl&amp; rhs)
: m_x(rhs.m_x)
, m_y(rhs.m_y)
{
}

spline_interpolation::spline_interpolation(const spline_interpolation&amp; rhs)
: interpolation_imp(rhs)
, m_y2(rhs.m_y2)
{
}

spline_interpolation* spline_interpolation::clone() const
{
  return new spline_interpolation(*this);
}
              </code></pre>
              </div>
            </div>
          </section>
        </section>

        <section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Design principles
                </h1>
              </div>
              <div class="main">

                <ul>
                  <li><strong>B</strong> should inherit from <strong>A</strong>
                    if <strong>B</strong> is a kind of <strong>A</strong></li>
                  <li><strong>B</strong> should inherit from <strong>A</strong>
                    if there exists an "is-a" relation between
                    <strong>A</strong> and <strong>B</strong></li>
                </ul>
                <p class="fragment text-center">That's <b>WRONG</b></p>
                <div class="fragment">
                  <ul>
                    <li><strong>B</strong> should inherit from
                      <strong>A</strong> if <strong>B</strong> behaves like
                      <strong>A</strong> in the context of your program</li>
                    <li><strong>B</strong> should inherit from
                      <strong>A</strong> if you want <strong>A</strong> to be
                      <b>substitutable</b></li>
                  </ul>
                </div>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Design principles
                </h1>
              </div>
              <div class="main">

                <p><strong>Liskov Substitution Principle</strong> (LSP)</p>
                <p>If <strong>S</strong> is a subtype of <strong>T</strong>,
                  then objects of type <strong>T</strong> in a program may be
                  replaced with objects of type <strong>S</strong> without
                  altering any of the desirable property of the propgram</p>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Design principles
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class rectangle : public drawable
{
  public:

    virtual ~rectangle();
    virtual vod draw(canvas&amp;) const;
    virtual void resize(size_t length, size_t width);
};
              </code></pre>
                <p class="text-center">Should square inherit from rectangle?</p>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Design principles
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class square: public rectangle
{
  public:

    virtual ~square();
    virtual vod draw(canvas&amp;) const;
    virtual void resize(size_t length, size_t width); // ??
};
              </code></pre>
                <p class="fragment text-center">square should NOT inherit from
                  rectangle</p>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Design principles
                </h1>
              </div>
              <div class="main">

                <p>Non virtual interface</p>
                <pre><code class="cpp">
class interpolation
{
  public:

    double interplate(double x) const;

  private:

    virtual double interpolate_impl(double x) const = 0;
};
              </code></pre>
                <pre><code class="cpp">
double interpolation::interpolate(double x) const
{
  // add code that should be executed before any call to
  // interpolate_impl, whatever the inheriting class is.
  double res = interpolate_impl(x);
  // add code that should be executed after any call to
  // interpolate_impl, whatever the inheriting class is.
  return res;
}
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Design principles
                </h1>
              </div>
              <div class="main">

                <p>Template method (pattern)</p>
                <pre><code class="cpp">
class algo
{
  public:

    void run();

  private:

    virtual void first_step();
    virtual void second_step();
    virtual void third_step();
};
              </code></pre>
                <pre><code class="cpp">
void algo::run()
{
  first_step();
  second_step();
  third_step();
}
              </code></pre>
              </div>
            </div>
          </section>
        </section>

        <section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  non virtual interface
                </h1>
              </div>
              <div class="main">

                <p>Implement a <strong>find_upper_bound</strong> method in
                  interpolation_impl that:</p>
                <ul>
                  <li>returns the index of the abscissa greater than or equal to
                    its argument,</li>
                  <li>throws an exception if the argument if out of the abscissa
                    bounds.</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  non virtual interface
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class interpolation_impl
{
  protected:

    size_t find_upper_bound(double x) const;

  // as before ...
};
              </code></pre>
                <pre><code class="cpp">
size_t interpolation_impl::find_upper_bound(double x) const
{
  if (x &lt; m_x.front() || x &gt; m_x.back())
  {
    throw std::runtime_error("x out of bounds");
  }
  auto iter = std::upper_bound(m_x.cbegin(), m_x.cend(), x);
  size_t index = static_cast&lt;size_t&gt;( iter - m_x.cbegin());
  return index;
}
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  non virtual interface
                </h1>
              </div>
              <div class="main">

                <p>Implement the interpolate method of spline_interpolation:</p>
                <ul>
                  <li>use the <strong>find_upper_bound</strong> method
                    previously defined,</li>
                  <li>use the <strong>spline_interpolate</strong> function
                    provided in interpolation_impl.hpp.</li>
                </ul>
                <pre class="fragment"><code class="cpp">
double spline_interpolation::interpolate(double x) const
{
  size_t upper_bound = find_upper_bound(x);
  return spline_interpolate(get_x()[upper_bound-1], get_x()[upper_bound],
  get_y()[upper_bound-1], get_y()[upper_bound],
  m_y2[upper_bound-1], m_y2[upper_boud],
  x);
}
              </code></pre>
                <p class="fragment text-center">What is the issue with this
                  implementation?</p>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  non virtual interface
                </h1>
              </div>
              <div class="main">

                <p>Refactor the implementation to avoid code duplication when
                  adding other interpolation methods:</p>
                <ul>
                  <li>Rename the current <strong>interpolate</strong> method
                    into <strong>interpolate_impl</strong>.</li>
                  <li><strong>interpolate_impl</strong> should be private and
                    take the result of <strong>find_upper_bound</strong> as a
                    additional parameter.</li>
                  <li>Add an interpolate method that acts as a NVI / template
                    method.</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  non virtual interface
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class interpolation_impl
{
  public:

    // Not virtual anymore
    double interpolate(double x) const;

  private:

    size_t find_upper_bound(double x) const;
    virtual double interpolate_impl(double x, size_t upper_bound) const  = 0;

    // as before ...
};
              </code></pre>
                <pre><code class="cpp">
class spline_interpolation : public interpolation_impl
{
  private:

    double interpolate_impl(double x, size_t upper_bound) const override;

    // as before ...
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  non virtual interface
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
double interpolation_impl::interpolate(double x) const
{
  size_t upper_bound = find_upper_bound(x);
  return interpolate_impl(x, upper_bound);
}

double spline_interpolation::interpolate_impl(double x, size_t upper_bound) const
{
  return spline_interpolate(get_x()[upper_bound-1], get_x()[upper_bound],
  get_y()[upper_bound-1], get_y()[upper_bound],
  m_y2[upper_bound-1], m_y2[upper_boud],
  x);
}
              </code></pre>
              </div>
            </div>
          </section>
        </section>

        <section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Private inheritance
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class my_vector : public std::vector&lt;double&gt;
{
  public:

    explicit my_vector(const std::string&amp; name);
    ~my_vector();

  private:

    std::string m_name;
};
              </code></pre>
                <p class="text-center">DON'T.DO.THAT.</p>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Private inheritance
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class my_vector
{
  public:

    double&amp; operator[](size_t i) { return m_data[i]; }
    const double &amp; operator[](size_t i) const { return m_data[i]; }
    // etc ...

  private:

    std::vector&lt;double&gt; m_data;
    std::string m_name;
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Private inheritance
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class my_vector : private std::vector&lt;double&gt;
{
  public:

    using base_type = std::vector&lt;doubl&gt;

    using base_type::size;
    using base_type::empty;
    using base_type::operator[];

  private:

    std::vector&lt;double&gt; m_data;
    std::string m_name;
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Private inheritance
                </h1>
              </div>
              <div class="main">

                <p>If <strong>B</strong> is a private base of
                  <strong>D</strong>:</p>
                <ul>
                  <li>All methods of <strong>B</strong> are private in
                    <strong>D</strong>.</li>
                  <li>You cannot assign a <strong>D*</strong> to a
                    <strong>B*</strong>.</li>
                  <li>Previous statements are not true for friend classes /
                    functions.</li>
                  <li><strong>D</strong> can only access public and protected
                    sections of <strong>B</strong>.</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Multiple inheritance
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class implementation : public interface1, public interface2
{
  public:

    virtual ~implementation() = default;
};
              </code></pre>
                <pre class="fragment"><code class="cpp">
class root {};

class interface1 : public root {};
class interface2 : public root {};

// The following is problematic
class implementation : public interface1, public interface2 {}
              </code></pre>
              </div>
            </div>
          </section>
        </section>

        <section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Private implementation / enveloppe
                </h1>
              </div>
              <div class="main">

                <p>Add a <strong>make_interpolation</strong> free function
                  that:</p>
                <ul>
                  <li>takes two vectors and a enum parameter to choose the type
                    of interpolation,</li>
                  <li>returns a unique pointer holding an
                    interpolation_impl.</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Private implementation / enveloppe
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation_impl.hpp
enum class interpolation_type
{
  linear,
  spline
};

using interpolation_ptr = std::unique_ptr&lt;interpolation_impl&gt;
interpolation_ptr make_interpolation(const std::vector&lt;double&gt;&amp; x,
const std::vector&lt;double&gt;&amp; y,
interplation_type it);
              </code></pre>
                <pre><code class="cpp">
// interpolation_impl.cpp
interpolation_ptr make_interpolation(const std::vector&lt;double&gt;&amp; x,
const std::vector&lt;double&gt;&amp; y,
interplation_type it)
{
  switch(it)
  {
    case linear:
    return std::make_unique&lt;linear_interpolation&gt;(x, y);
    clase spline:
    return std::make_unique&lt;spline_interpolation&gt;(x, y);
    default:
    return std::make_unique&lt;linear_interpolation&gt;(x, y);
  }
}
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Private implementation / enveloppe
                </h1>
              </div>
              <div class="main">

                <p>Add an <strong>interpolation</strong> class that:</p>
                <ul>
                  <li>Holds a pointer to interpolation_impl.</li>
                  <li>Implements the value semantics.</li>
                  <li>Has an interpolate method that forwards the call to
                    interpolation_impl.</li>
                  <li>Its constructor takes an enum parameter to choose the
                    interpolation type.</li>
                </ul>
              </div>
            </div>
          </section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Private implementation / enveloppe
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation.hpp
class interpolation
{
  public:

    interpolation(const std::vector&lt;double&gt;&amp; x,
    const std::vector&lt;double&gt;&amp; y,
    interpolation_type it);
    ~inteopolation_type() = default;

    interpolation(const interpolation&amp;);
    interpolation&amp; operator=(const interpolation&amp;);

    interpolation(interpolation&amp;&amp;) = default;
    interpolation&amp; operator=(interpolation&amp;&amp;) = default;

    double interpolate(double x) const;

  private:

    inteprolation_ptr p_impl;
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Private implementation / enveloppe
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
// interpolation.cpp
interpolation::interpolation(const std::vector&lt;double&gt;&amp; x,
const std::vector&lt;double&gt;&amp; y,
interpolation_type it)
: p_impl(make_interpolation(x, y, it);
{
}
interpolation::interpolation(const interpolation&amp; rhs)
: p_impl(rhs.p_impl-&gt;clone())
{
}

interpolation&amp; interpolation::operator=(const interpolation&amp; rhs)
{
  interpolation_impl tmp = rhs.p_impl-&gt;clone();
  std::swap(tmp, p_impl);
  return *this;
}

double interpolation::interpolate(double x) const
{
  return p_impl-&gt;interpolate(x);
}
              </code></pre>
              </div>
            </div>
          </section>
        </section>

        <section>
          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  ODE Solver
                </h1>
              </div>
              <div class="main">

                <p>You now have a good understanding of the concepts related to
                  polymorphism and the C++ programming technique called
                  Pimpl.</p>

                <p>A colleague comes to you and says that he wants to build a
                  user-friendly interface for his ODE solvers.</p>

                <p>At the moment he has only two methods: explicit Euler and
                  Runge-Kutta 2. But he hopes that with your help he will be
                  able to add many more.</p>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  ODE Solver
                </h1>
              </div>
              <div class="main">

                The first application he has in mind is to solve the well-known
                Lorenz equations given by
                $$
                \left\{
                \begin{array}{l}
                \frac{dx}{dt} = \sigma(y-x), \\\\
                \frac{dy}{dt} = x(\rho-z)-y, \\\\
                \frac{dz}{dt} = xy-\beta z.
                \end{array}
                \right.
                $$

              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  ODE API: usage example
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
double T = 50, t = 0;
std::size_t nite = 20000;
double dt = T/nite;

Lorenz lo(28, 10, 8./3);
std::vector&lt;double&gt; x0{5, -8, 6};

ODE ode(x0, lo, method::euler);

for(std::size_t i = 0; i &lt; nite; ++i)
{
  ode.one_step(t, dt);
  ode.print_sol();
  t += dt;
}
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  ODE API: Lorenz class
                </h1>
              </div>
              <div class="main">

                <pre><code class="cpp">
class Lorenz
{
  public:

    Lorenz(double rho, double sigma, double beta)
    : m_rho(rho)
    , m_sigma(sigma)
    , m_beta(beta)
    {}

    std::vector&lt;double&gt; operator()(double t, const std::vector&lt;double&gt;& x) const
    {
      return {
        m_sigma*(x[1] - x[0]),
        x[0]*(m_rho - x[2]) - x[1],
        x[0]*x[1] - m_beta*x[2]
      };
    }

  private:

    double m_rho;
    double m_sigma;
    double m_beta;
};
              </code></pre>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">
                  Reminder
                </h1>
              </div>
              <div class="main">

                <p>The Euler method is</p>
                $$
                y_{n+1} = y_n + \Delta t f(t_n, y_n).
                $$

                <p>The Runge-Kutta method of order $2$ is</p>
                $$
                y_{n+1} = y_n + \Delta t f\left(t_n + \frac{\Delta t}{2}, y_n +
                \frac{\Delta t}{2}f(t_n, y_n)\right).
                $$
              </div>
            </div>
          </section>

        </section>
      </div>
    </div>
    <script type="module" src="/main.js"></script>
  </body>

</html>
